<!DOCTYPE html>
<html>

<head>
  <title>New Boutiques Integrator</title>
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/night.css">
  <link rel="stylesheet" href="plugin/highlight/style/monokai-sublime.css">
  <meta charset="utf-8"/>
</head>

<body>
  <div class="reveal">
    <div class="slides">

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section>

  <section id="title">
    <img src="images/cbrain-large_white_alpha.png" class="cbblue">
    <h2>The New Boutiques Integrator</h2>
    Pierre Rioux
    <p>
    <small>CBRAIN Internal Documentation, September 2021</small>
    <p>
    <small><a href="https://github.com/aces/cbrain/pull/1153" target="_blank">GitHub Pull Request</a></small>
  </section>

<!-- ****************************** -->

  <section id="toc">
    <h3>A Presentation In Several Parts:</h3>
    <ul>
      <li>1. <a href="#/part1">What Is Boutiques</a> (3 slides)</li>
      <li>2. <a href="#/part2">The Models</a> (5 slides)</li>
      <li>3. <a href="#/part3">CbrainTask Class Hierarchy</a> (3 slides)</li>
      <li>4. <a href="#/part4">Standard Task Integration</a> (4 slides)</li>
      <li>5. <a href="#/part5">Old Boutiques Integration</a> (13 slides)</li>
      <li><i>New Boutiques Integration:</i>
        <ul>
          <li>6. <a href="#/part6">Boot-time</a> (12 slides)</li>
          <li>7. <a href="#/part7">Run-time</a> (8 slides)</li>
          <li>8. <a href="#/part8">View Code</a> (16 slides)</li>
          <li>9. <a href="#/part9">Code Conventions</a> (6 slides)</li>
          <li>10. <a href="#/part10">Customization And Configuration</a> (7 slides)</li>
        </ul>
      </li>
    </ul>
  </section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section>

  <section id="part1">
    <h2>Part 1</h2>
    <h3>What Is Boutiques</h3>
  </section>

<!-- ****************************** -->

  <section id="btq_proj">
    <h3>The Project</h3>
      <ul>
        <li>Started in 2015 by Tristan Glatard</li>
        <li>Originally specific to generating CBRAIN task code</li>
        <li>Eventually made into a generic tool description platform</li>
        <li>Modern code base is mostly in Python</li>
        <li>Includes full specifications and utilities</li>
      <ul>
      <p>
      <img src="http://boutiques.github.io/images/logo.png" width="100" height="100" alt="Boutiques logo"/>
      <a href="https://github.com/boutiques/boutiques" target="_blank">https://github.com/boutiques/boutiques</a>
  </section>

<!-- ****************************** -->

  <section id="btq_desc">
    <h3>A Descriptor</h3>
    <pre class="transp"><code class="json" data-trim>
{
    "tool-version": "6.0.4",
    "name": "oxford_asl",
    "author": "Oxford Centre for Functional MRI of the Brain (FMRIB)",
    "description": "oxford_asl is part of BASIL",
    "command-line": "oxford_asl [INPUT_FILE] [OUTPUT_DIR] [MASK]...",
    "schema-version": "0.5",
    "container-image": {
        "image": "mcin/docker-fsl:latest",
        "index": "docker://",
        "type": "singularity"
    },
    "inputs": [  stuff ],
    "output-files": [ stuff  ],
    "custom": { stuff }
}
    </code></pre>
  </section>

</section>


<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section>

  <section id="part2">
    <h2>Part 2</h2>
    <h3>The Models</h3>
  </section>

<!-- ****************************** -->

  <section id="model_tool">
    <h3>Tool</h3>
    <ul>
      <li>Identifies and describes a scientific tool</li>
      <li>One record for all deployments</li>
      <li>Database table: <strong>tools</strong></li>
    </ul>
    <hr>
    <h5>Main Attributes</h5>
    <table>
      <tr>
        <td>id</td><td><em>3</em></td>
      <tr>
      <tr>
        <td>name</td><td><em>"Civet"</em></td>
      <tr>
      <tr>
        <td>cbrain_task_class_name</td><td><em>"CbrainTask::Civet"</em></td>
      <tr>
    </table>
  </section>

<!-- ****************************** -->

  <section id="model_toolconfig">
    <h3>ToolConfig</h3>
    <ul>
      <li>Identifies and describes an instance of a tool</li>
      <li>Many per tool and per Execution Server (Bourreau)</li>
      <li>Database table: <strong>tool_configs</strong></li>
    </ul>
    <hr>
    <h5>Main Attributes</h5>
    <table>
      <tr>
        <td>id</td><td><em>513</em></td>
      </tr>
      <tr>
        <td>tool_id</td><td><em>3</em> ("Civet")</td>
      </tr>
      <tr>
        <td>bourreau_id</td><td><em>56</em> ("Beluga")</td>
      </tr>
      <tr>
        <td>version_name</td><td><em>"2.1.1"</em></td>
      </tr>
      <tr>
        <td>(config stuff)</td><td><em>(path, env, etc)</em></td>
      </tr>
    </table>
  </section>

<!-- ****************************** -->

  <section id="model_cbraintask">
    <h3>CbrainTask</h3>
    <ul>
      <li>Tracks a single cluster job</li>
      <li>Is associated to one ToolConfig
      <br><small>(and thus, to one Tool and one Bourreau)</small>
      </li>
      <li>Database table: <strong>tasks</strong></li>
    </ul>
    <hr>
    <h5>Main Attributes</h5>
    <table>
      <tr>
        <td>id</td><td><em>60021</em></td>
      </tr>
      <tr>
        <td>tool_config_id</td><td><em>513</em> (Tool "Civet" on "Beluga")</td>
      </tr>
      <tr>
        <td>type</td><td><em>CbrainTask::Civet</em> (Ruby class from Tool)</td>
      </tr>
      <tr>
        <td>cluster_jobid</td><td><em>285283</em> (SLURM ID on Beluga)</td>
      </tr>
      <tr>
        <td>status</td><td><em>"On CPU"</em></td>
      </tr>
    </table>
  </section>

<!-- ****************************** -->

  <section id="model_relationships">
    <h3>Relationships</h3>
    <img src="images/model_relationships.png">
  </section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section>

  <section id="part3">
    <h2>Part 3</h2>
    <h3>CbrainTask Class Hierarchy</h3>
  </section>

<!-- ****************************** -->

  <section id="base_classes">
    <h3>Base Classes</h3>
    <img src="images/base_classes.png">
  </section>

<!-- ****************************** -->

  <section id="class_sep">
    <h3>Portal vs Bourreau</h3>
    <img src="images/class_sep.png">
  </section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section>

  <section id="part4">
    <h2>Part 4</h2>
    <h3>Standard Task Integration</h3>
  </section>

<!-- ****************************** -->

  <section id="why_plugins">
    <h3>Plugins</h3>
    CBRAIN uses plugins to extend its functionality.
    <p>
    Plugins can provide new Userfile models,<br>
    new libraries and new task classes.
    <p>
    This allow the CBRAIN code base to be independent<br>
    of the code that provides these extended functions.
    <p>
    Plugins can be developed by other developers<br>
    and CBRAIN admins can just install them.
    <p>
    But this requires all plugin code to follow certain coding<br>
    conventions (APIs) and structure their code in a particular way.
    <p>
    The CBRAIN code base comes with one built-in plugin,<br>
    <em>cbrain-plugins-base</em>, which provides some simple<br>
    Userfile classes and a few example task classes.
  </section>

<!-- ****************************** -->

  <section id="plugins_struct">
    <h3>Plugins Files Structure</h3>
    <small>
    <table>
      <tr>
        <th>File</th>
        <th>Role</th>
        <th>Class declaration</th>
      </tr>
      <tr>
        <td>PLUGIN.../portal/tool_name.rb</td>
        <td>Code loaded by Portal</td>
        <td><pre>class CbrainTask::ToolName &lt; PortalTask</pre></td>
      </tr>
      <tr>
        <td>PLUGIN.../bourreau/tool_name.rb</td>
        <td>Code loaded by Bourreau</td>
        <td><pre>class CbrainTask::ToolName &lt; ClusterTask</pre></td>
      </tr>
      <tr>
        <td>PLUGIN.../views/_task_params.html.erb</td>
        <td>Code rendered by Portal</td>
        <td></td>
      </tr>
    </table>
    <p>
    For more info:<br>
    <ul>
      <li><a href="https://github.com/aces/cbrain/wiki/CbrainTask-Programmer-Guide" target="_blank">CbrainTask Programmer Guide</a></li>
      <li><a href="https://prioux.github.io/cbrain-presentation/#/tasks1" target="_blank">CBRAIN Presentation</a></li>
    </ul>
    </small>
  </section>

<!-- ****************************** -->

  <section id="class_file_loc">
    <h3>Ruby Code File Locations</h3>
    <img src="images/class_file_loc.png">
  </section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section>

  <section id="part5">
    <h2>Part 5</h2>
    <h3>Old Boutiques Integration</h3>
  </section>

<!-- ****************************** -->

  <section id="old_flow">
    <h3>Old Integration Flow</h3>
    <ul>
      <li>Integrations happen during boot</li>
      <li>This directory is scanned:<br>
          <em>cbrain_plugins/installed-plugins/cbrain_task_descriptors</em></li>
      <li>It contains pairs of files, e.g.<br>
          <em>tool_name.json</em>, <em>tool_name.rb</em></li>
      <li>The <em>.rb</em> file is a symlink to a common loader</li>
      <li>It invokes the integrator code with:
          <ul>
            <li>'<em>ToolName</em>' as a name for the classes to create, created from the basename of the file</li>
            <li>The <em>.json</em> file content</li>
          </ul>
      </li>
      <li>Virtual files are then created and loaded, different for each descriptor</li>
    </ul>
  </section>

<!-- ****************************** -->

  <section id="old_diagram">
    <h3>Old Integration Diagram</h3>
    <img src="images/old_integ1.png">
  </section>

<!-- ****************************** -->

  <section id="old_port_temp_1">
    <h3>Old Templating: Source</h3>
    <img src="images/portal_template.png">
    <small>Excerpt from <em>portal.rb.erb</em> with syntax highlighting</small>
  </section>

<!-- ****************************** -->

  <section id="old_port_temp_2">
    <h3>Old Templating: Levels</h3>

<pre class="ascode">
<em>%unless defaults.empty?</em>
  # Default values for some (all?) of <em>&lt;%= name %&gt;</em>'s parameters. Those values
  # reflect the defaults taken by the tool's developer; feel free to change
  # them to match your platform's requirements.
  def self.default_launch_args #:nodoc:
    super.merge({
<em>%   id_width = max_width.(defaults, 'id') + "'".length</em>
<em>%   defaults.each do |default|</em>
      <em>&lt;%=
        ":'%-#{id_width}s =&gt; %s," % [
          default['id'] + "'",
          default['default-value'].inspect
        ]
      %&gt;</em>
<em>%   end</em>
    })
  end
<em>% end</em>
</pre>
    <small>In <em>YELLOW</em>: code executed at integration time<br>
    In WHITE: literal code ending up in the class</small>
  </section>

<!-- ****************************** -->

  <section id="old_port_temp_3">
    <h3>Old Templating: Result 1</h3>

     If the JSON descriptor has <em>no defaults</em> for any of its inputs:<br>

<pre class="ascode">
&nbsp;
&nbsp;
# (no Ruby statements end up in the generated code)
&nbsp;
&nbsp;
</pre>
    <small>Generated Portal code</small>
  </section>

<!-- ****************************** -->

  <section id="old_port_temp_4">
    <h3>Old Templating: Result 2</h3>

     If the JSON descriptor has <em>some defaults</em> for any of its inputs:<br>
<pre><code class="ruby">
  # Default values for some (all?) of CivetRerun's parameters. Those values
  # reflect the defaults taken by the tool's developer; feel free to change
  # them to match your platform's requirements.
  def self.default_launch_args #:nodoc:
    super.merge({
      :'model'             =&gt; "icbm152nl_09s",
      :'template'          =&gt; "0.50",
      :'lsq'               =&gt; 12,
      :'interp'            =&gt; "trilinear",
      :'n3_dist'           =&gt; 75,
      :'pve_advanced'      =&gt; true,
      :'surfreg_model'     =&gt; "icbm152MCsym",
      :'combine_surface'   =&gt; true,
      :'thickness_methods' =&gt; "tlaplace",
      :'thickness_kernels' =&gt; "30",
      :'resample_surface'  =&gt; true,
      :'surf_atlas'        =&gt; "lobes",
    })
  end
</code></pre>
    <small>Generated Portal code</small>
  </section>

<!-- ****************************** -->

  <section id="old_params_temp_1">
    <h3>Params Template Of Template</h3>
    <img src="images/params_template.png">
    <small>Excerpt from <em>task_params.html.erb.erb</em> with syntax highlighting<br>
    Note that even my text editor gets confused!</small>
  </section>

<!-- ****************************** -->

  <section id="old_params_temp_2">
    <h3>Params Templates Levels</h3>
<pre class="ascode">
<em>  &lt;%-
    classes  = [ 'tsk-prm', type.to_s ]
    classes &lt;&lt; 'list' if list
    classes &lt;&lt; 'prm-grp-mbr' if isGroupMember
  -%&gt;</em>
    &lt;%% id = '<em>&lt;%= id %&gt;</em>' %&gt;
    <strong>&lt;li class="</strong>&lt;%%= id %&gt; <em>&lt;%= classes.join(' ') %&gt;</em>"<strong>&gt;</strong>
      &lt;%%
  <em>&lt;%- if type == :flag -%&gt;</em>
        # Flag input toggle
        checkbox.(id, name: id)

  <em>&lt;%- end -%&gt;</em>
        # Name/Label
        label.(id, %q{ <em>&lt;%= param['name'] %&gt;</em> },
<i>(91 lines skipped, I am not kidding)</i>
      %&gt;
    <strong>&lt;/li&gt;</strong>
</pre>
<small>In <em>YELLOW</em>: code executed at integration time<br>
In WHITE: templated code ending up in the class<br>
In <strong>CYAN</strong>: literal code ending up in the HTML</small>
  </section>

<!-- ****************************** -->

  <section id="old_params_temp_3">
    <h3>Generated Params HTML.erb</h3>
<pre class="ascode">
    &lt;% id = 'combine_surface' %&gt;
    <strong>&lt;li class="</strong>&lt;%= id %&gt;<strong> tsk-prm flag prm-grp-mbr"&gt;</strong>
      &lt;%
        # Flag input toggle
        checkbox.(id, name: id)

        # Name/Label
        label.(id, %q{ Combine left/right surfaces },
          optional: true,
          flag:     '-combine-surfaces'
        )

        # Description
        description.(&lt;&lt;-'DESC',true)
          Combine left/right surfaces
        DESC
      %&gt;
    <strong>&lt;/li&gt;</strong>
</pre>
    <small>Sample generated <em>_task_params.html.erb</em></small>
  </section>

<!-- ****************************** -->

  <section id="old_params_temp_4">
    <h3>Generated Params HTML</h3>
    <img src="images/params_html.png">
  </section>

<!-- ****************************** -->

  <section id="old_params_temp_5">
    <h3>Browser HTML</h3>
    <img src="images/browser_params.png">
  </section>

<!-- ****************************** -->

  <section id="old_consequences">
    <h3>Old Integration: Consequences</h3>
    <ul>
      <li>There is a single set of templates, each quite big</li>
      <li>These templates must try to generate all the features of Boutiques</li>
      <li>The templates are very complicated to edit and maintain</li>
      <li>At run time, the descriptors are no longer available</li>
    </ul>
    <p>
    See for instance, some old integrator templates:<br>
    <ul>
      <li><a href="https://github.com/aces/cbrain/blob/master/BrainPortal/lib/cbrain_task_generators/templates/portal.rb.erb" target="_blank">portal.rb.erb</a></li>
      <li><a href="https://github.com/aces/cbrain/blob/master/BrainPortal/lib/cbrain_task_generators/templates/task_params.html.erb.erb" target="_blank">task_params.html.erb.erb</a></li>
    </ul>
  </section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section>

  <section id="part6">
    <h2>Part 6</h2>
    <h3>New Boutiques Integration</h3>
    <small>(finally!)</small>
    <h5>Boot-time Integration</h5>
  </section>

<!-- ****************************** -->

  <section id="goals">
    <h3>Goals</h3>
    <h5>Maintenance</h5>
    <ul>
      <li>Remove the templating system</li>
      <li>Maintain compatibility with old integrator</li>
    </ul><p>
    <h5>Task Class Implementation</h5>
    <ul>
      <li>All tasks inherit from a new base class</li>
      <li>This base class derives its behavior from a descriptor at run time</li>
      <li>All behaviors are provided by small methods</li>
      <li>The task's class itself is initially empty</li>
    </ul><p>
    <h5>View Code Implementation</h5>
    <ul>
      <li>All the view templates are provided by small partials</li>
      <li>Individual partials can be replaced/overriden</li>
      <li>The new set of partials provides all the exact same UI as the original integrator</li>
    </ul>
  </section>

<!-- ****************************** -->

  <section id="helperclass1">
    <h3>Helper Class For Descriptors</h3>
    A new support module was created: BoutiquesSupport
    <p>
    It's located in <em>lib/boutiques_support.rb</em>
    <p>
    <pre><code class="ruby" data-trim>
irb&gt; desc = BoutiquesSupport::BoutiquesDescriptor.new_from_file "civet_rerun.json"
irb&gt; desc.class
BoutiquesSupport::BoutiquesDescriptor
irb&gt; desc[:name]
"CivetRerun"
irb&gt; desc['name']
"CivetRerun"
irb&gt; desc.name
"CivetRerun"
irb&gt; desc['tool-version']
"2.1.1"
irb&gt; desc.tool_version # note the _ instead of -
"2.1.1"
irb&gt; desc.inputs.class
Array
irb&gt; desc.inputs.first
{"name"=&gt;"Existing CIVET output", "id"=&gt;"civet_in", "description"=&gt;"..."}
irb&gt; desc.inputs.first.class
BoutiquesSupport::Input
    </code></pre>
  </section>

<!-- ****************************** -->

  <section id="helperclass2">
    <h3>Helper Class Usage</h3>
    The new Boutiques helper classes are implemented as<br>
    subclasses of my <em>RestrictedHash</em> class.
    <p>
    This means they make sure all attributes accessed through
    <strong>methods</strong> or <strong>hash-like []</strong>
    are are allowed in Boutiques.
    <pre><code class="ruby" data-trim>
# This works:
desc['name']  = 'MyNewName'

# These three will raise an exception: there is no 'email' field in
# the boutiques schema
desc.email                               # reading as a method
desc.email    = 'pierre.rioux@mcgill.ca' # write as method
desc['email'] = 'pierre.rioux@mcgill.ca' # write as hash
    </code></pre><p>
    In general, the new integration code uses the <strong>method</strong>
    access scheme (<em>desc.abc</em>) instead of the hash
    access scheme (<em>desc['abc']</em>)
  </section>

<!-- ****************************** -->

  <section id="new_plugin_dir">
    <h3>Plugin File Location</h3>
    A descriptor <em>mytool.json</em> is integrated
    when located in the subdirectory called <em>boutiques_descriptors</em>.
    <p>
    Typical plugin files:<p>
    <pre class="ascode">
plugindir/cbrain_task/hello/portal/hello.rb     <strong># Tool 'hello', unrelated, standard integration</strong>
plugindir/cbrain_task/hello/bourreau/hello.rb
plugindir/cbrain_task/hello/views/_task_params.html.erb
plugindir/userfiles/mymodel/mymodel.rb          <strong># Some unrelated model</strong>
plugindur/cbrain_task_descriptors/oldtool.json  <strong># Tool 'oldtool', using old btq integration</strong>
<em>plugindir/boutiques_descriptors/mytool.json</em>     <strong># Tool 'mytool', new btq integration</strong>
</pre>
    <p>
    Symbolic links to these files are created in a special <strong>install</strong> directory by
    the CBRAIN sysadmin, at install time.
    <p>
    In particular, all the boutiques desciptors for the new integration end up
    linked into this new system subdirectory:<p>
<pre class="ascode">
<strong>{BrainPortal|Bourreau}</strong>/cbrain_plugins/installed-plugins/boutiques_descriptors
</pre>
  </section>

<!-- ****************************** -->

  <section id="new_boot">
    <h3>New Integration Boot</h3>
    <ul>
      <li>The boot process is faster and lighter</li>
      <li>Unlike the old integrator, we have:
        <ul>
          <li>No special fake class loader</li>
          <li>No ruby code templates to render and load dynamically</li>
          <li>No view templates to render and store in memory</li>
        </ul>
      </li>
      <li>All we do have is a set of JSON files in the <strong>install</strong> directory</li>
    </ul>
  </section>

<!-- ****************************** -->

  <section id="new_boot_summary">
    <h3>Boot-time Summary</h3>
    At boot time, we scan all the <em>.json</em> files installed.
    <p>
    For <i>each JSON file</i>:
    <ol>
      <li>We load and store the JSON descriptor</li>
      <li>If the descriptor is for a new Tool, we auto configure the tool</li>
      <li>If the descriptor is for a new version, we auto configure a ToolConfig</li>
      <li>We create the task handler class as <em>BoutiquesTask::ToolName</em></li>
    </ol>
    <p>
    The next four slides describe each of these steps.
  </section>

<!-- ****************************** -->

  <section id="new_boot_load">
    <h3>Boot 1: Loading The Descriptors</h3>
    For <i>each JSON file</i>:
    <ul>
      <li>We load the descriptor's content into a <em>BoutiquesSupport::BoutiquesDescriptor</em> object</li>
      <li>We extract two values: <strong>name</strong> and <strong>tool-version</strong></li>
      <li>We store in a <i>global, persistent hash</i> the association<br>
        <em>[ </em><strong>tool_name</strong><em>, </em><strong>tool_version</strong><em> ] => full_descriptor_content</em>
      </li>
      <li>This hash is called the <i>descriptor register</i>, and is maintained by the ToolConfig class (mostly because it will be used by actual ToolConfigs later on)</li>
    </ul>
  </section>

<!-- ****************************** -->

  <section id="new_boot_tool">
    <h3>Boot 2: Creating The Tool</h3>
    For <i>each JSON file</i>:
    <ul>
      <li>We examine the <strong>name</strong> again</li>
      <li>If a tool with that name already exists, we move on</li>
      <li>Otherwise, we create a new Tool in the DB</li>
      <li>The Tool's <em>cbrain_task_class_name</em> (see <a href="#/model_tool">Part 2</a>) is set to <em>BoutiquesTask::ToolName</em></li>
      <li>This string represents the tool's task's implementation class</li>
      <li>The class itself is created later (see you in two slides)</li>
    </ul>
  </section>

<!-- ****************************** -->

  <section id="new_boot_toolconfig">
    <h3>Boot 3: Creating The Tool Config</h3>
    For <i>each JSON file</i>:
    <ul>
      <li>Note: all of this only happens when the current Rails app is a Bourreau</li>
      <li>We examine the <strong>name</strong> and <strong>tool-version</strong> again</li>
      <li>If a ToolConfig for these two values already exists, we move on</li>
      <li>Otherwise, we create a new ToolConfig in the DB:
        <ul>
          <li>Tool: (the Tool found in the previous slide)</li>
          <li>version_name: <strong>tool-version</strong></li>
          <li>bourreau_id: (the current Rails app ID)</li>
        </ul>
      </li>
    </ul>
  </section>

<!-- ****************************** -->

  <section id="new_boot_btq_class">
    <h3>Boot 4: Class Creation</h3>
    For <i>each JSON file</i>:
    <p>
    We create, in memory, a new Ruby class that corresponds to
    the string <em>BoutiquesTask::ToolName</em> configured in the Tool object.
    <p>
    That class is an <b>empty class that inherits everything</b>.
    <p>
    On the portal side, it behaves like this piece of code:
    <pre><code class="ruby" data-trim>
class BoutiquesTask::ToolName &lt; BoutiquesPortalTask
end
    </code></pre>
    On the bourreau side, it's only slightly different:
    <pre><code class="ruby" data-trim>
class BoutiquesTask::ToolName &lt; BoutiquesClusterTask
end
    </code></pre>
  </section>

<!-- ****************************** -->

  <section id="new_class">
    <h3>New Integrator Class Hierarchy</h3>
    <img src="images/btq_new_classes.png">
  </section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section>

  <section id="part7">
    <h2>Part 7</h2>
    <h3>New Boutiques Integration</h3>
    <h5>Ruby Run-time Integration</h5>
  </section>

<!-- ****************************** -->

  <section id="portal_calls">
    <h3>Portal Calls</h3>
    <img src="images/portal_calls.png">
  </section>

<!-- ****************************** -->

  <section id="bourreau_calls">
    <h3>Bourreau Calls</h3>
    <img src="images/bourreau_calls.png">
  </section>

<!-- ****************************** -->

  <section id="calls_recap">
    <h3>Three Integrators Recap</h3>
    Everything in <em>yellow</em> in the previous slides
    is code or templates designed specifically for each tool.
    <p>
    Here's what is responsible for creating these things under the three integrators:
    <ul>
      <li><strong>Standard Ruby Integration:</strong><br>
        a programmer writes the Ruby files and templates
      </li>
      <li><strong>Old Boutiques Integretor:</strong><br>
        at boot time, the descriptor is loaded and
        code and views are generated from templates
      </li>
      <li><strong>New Boutiques Integrator:</strong><br>
        a single set of static Ruby files and templates
        exists but their run-time behavior changes based on the
        content of a descriptor
      </li>
    </ul>
  </section>

<!-- ****************************** -->

  <section id="portal_code1">
    <h3>Portal: How The Descriptor Is Fetched</h3>
    <pre><code class="ruby" data-trim>
class BoutiquesPortalTask &lt; PortalTask

  # This method returns the BoutiquesDescriptor
  # directly associated with the ToolConfig for the task
  def boutiques_descriptor
    self.tool_config.boutiques_descriptor
  end

  #...

end
    </code></pre>
    <small>Excerpt from <em>app/models/boutiques_portal_task.rb</em></small>
    <pre><code class="ruby" data-trim>
class BoutiquesTask::ToolName &lt; BoutiquesPortalTask
  # Nothing at all in the class!
end
    </code></pre>
    <small>Boot time code for the task</small>

  </section>

<!-- ****************************** -->

  <section id="portal_code2">
    <h3>Portal: How The Task Behavior Is<br>
        Controlled By A Descriptor</h3>
    <img src="images/portal_fetch_desc.png">
  </section>

<!-- ****************************** -->

  <section id="cluster_code1">
    <h3>Bourreau: How The Descriptor Is Fetched</h3>
    <pre><code class="ruby" data-trim>
class BoutiquesClusterTask &lt; ClusterTask

  # This method returns the BoutiquesDescriptor
  # directly associated with the ToolConfig for the task
  def boutiques_descriptor
    self.tool_config.boutiques_descriptor
  end

  #...

end
    </code></pre>
    <small>Excerpt from <em>app/models/boutiques_cluster_task.rb</em></small>
    <pre><code class="ruby" data-trim>
class BoutiquesTask::ToolName &lt; BoutiquesClusterTask
  # Again, nothing at all in the class!
end
    </code></pre>
    <small>Boot time code for the task</small>

  </section>

<!-- ****************************** -->

  <section id="cluster_code2">
    <h3>Bourreau: How Task Behavior Is<br>
        Controlled By A Descriptor</h3>
    <img src="images/bourreau_fetch_desc.png">
  </section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section>

  <section id="part8">
    <h2>Part 8</h2>
    <h3>New Boutiques Integration</h3>
    <h5>View Code Integration</h5>
  </section>

<!-- ****************************** -->

  <section id="partials">
    <h3>Separate HTML Partials</h3>
    The original single large template of template<br>
    <em>_task_params.html.erb.erb</em> (see <a href="#/old_params_temp_1">part 5</a>)<br>
    has been split into a set of smaller templates:
<pre>
-rw-r--r--  1 prioux  staff   2305 Oct  4 11:00 _boutiques_group.html.erb
-rw-r--r--  1 prioux  staff   4127 Oct  4 11:00 _boutiques_input.html.erb
-rw-r--r--  1 prioux  staff    970 Oct  4 11:00 _boutiques_preview.html.erb
-rw-r--r--  1 prioux  staff    995 Oct  4 11:00 _description.html.erb
-rw-r--r--  1 prioux  staff   2326 Oct  4 11:00 _dropdown.html.erb
-rw-r--r--  1 prioux  staff   4602 Oct  4 11:00 _edit_help.html.erb
-rw-r--r--  1 prioux  staff  28488 Oct  4 11:00 _form_js.html.erb
-rw-r--r--  1 prioux  staff    991 Oct  4 11:00 _group_checkbox.html.erb
-rw-r--r--  1 prioux  staff   1622 Oct  4 11:00 _html_input.html.erb
-rw-r--r--  1 prioux  staff   1905 Oct  4 11:00 _html_input_list.html.erb
-rw-r--r--  1 prioux  staff   1811 Oct  4 11:00 _html_select.html.erb
-rw-r--r--  1 prioux  staff   1910 Oct  4 11:00 _input_checkbox.html.erb
-rw-r--r--  1 prioux  staff   1219 Oct  4 11:00 _input_label.html.erb
-rw-r--r--  1 prioux  staff   1216 Oct  4 11:00 _opt_checkbox.html.erb
-rw-r--r--  1 prioux  staff   3085 Oct  4 11:00 _show_params.html.erb
-rw-r--r--  1 prioux  staff   2530 Oct  4 11:00 _task_params.html.erb
</pre>
  </section>

<!-- ****************************** -->

  <section id="partials_hierarchy">
    <h3>Partials Hierarchy</h3>
    All these partials invoke each other along these render paths:
<pre>
_task_params.html.erb
  &#x21b3; _boutiques_input.html.erb    # one or many; see below for def
  &#x21b3; _boutiques_group.html.erb    # zero, one, or many
    &#x21b3; _group_checkbox.html.erb
    &#x21b3; _boutiques_input.html.erb  # one or many
      &#x21b3; _opt_checkbox.html.erb
      &#x21b3; _input_label.html.erb
      &#x21b3; One of:
         _input_checkbox.html.erb
         _dropdown.html.erb
         _html_input.html.erb
         _html_input_list.html.erb
         _html_select.html.erb
      &#x21b3; _description.html.erb
  &#x21b3; _boutiques_preview.html.erb  # just a div
  &#x21b3; _form_js.html.erb            # templated

_show_params.html.erb # separate page

_edit_help.html.erb   # separate overlay
</pre>
  </section>

<!-- ****************************** -->

  <section id="params_browser_all">
    <h3>Layout Breakdown: All</h3>
    <img src="images/par_0_all.png">
  </section>

<!-- ****************************** -->

  <section id="params_browser_params">
    <h3>Layout Breakdown: Params</h3>
    <img src="images/par_1_params.png">
  </section>

<!-- ****************************** -->

  <section id="params_browser_groups">
    <h3>Layout Breakdown: Groups</h3>
    <img src="images/par_2_groups.png">
  </section>

<!-- ****************************** -->

  <section id="params_browser_labels">
    <h3>Layout Breakdown: Labels</h3>
    <img src="images/par_3_labels.png">
  </section>

<!-- ****************************** -->

  <section id="params_browser_checkboxes">
    <h3>Layout Breakdown: Checkboxes</h3>
    <img src="images/par_4_checkboxes.png">
  </section>

<!-- ****************************** -->

  <section id="params_browser_inputs">
    <h3>Layout Breakdown: Inputs</h3>
    <img src="images/par_5_inputs.png">
  </section>

<!-- ****************************** -->

  <section id="params_browser_descriptions">
    <h3>Layout Breakdown: Descriptions</h3>
    <img src="images/par_6_descriptions.png">
  </section>

<!-- ****************************** -->

  <section id="params_browser_multiple">
    <h3>Layout Breakdown: Multiple</h3>
    <img src="images/par_7_multiple.png">
  </section>

<!-- ****************************** -->

  <section id="partials_mods">
    <h3>Partials Changes</h3>
    The templating code was modified as follow:
    <p>
    <ul>
      <li>It was de-templated by one level</li>
      <li>Distinct elements get distinct partials</li>
      <li>The HTML code generated is controlled by <strong>@descriptor</strong></li>
      <li>Javascript logic is extracted into a separate file</li>
      <li>The javscript templated code was simplified</li>
    </ul>
  </section>

<!-- ****************************** -->

  <section id="partials_mods2">
    <h3>Example Partial: Label</h3>
    This partial receives <strong>input</strong> (a component of <strong>@descriptor</strong>) as a
    local Ruby variable.<p>
    <strong>input</strong> is a full <em>BoutiquesSupport::Input</em> object.
<pre><code class="erb" data-trim>
&lt;%-
  name = input.name
  flag = input.command_line_flag
  opt  = input.optional
-%&gt;

&lt;label class="tsk-prm-lbl" for="&lt;%= input.cb_invoke_html_id %&gt;"&gt;
  &lt;%= name %&gt;
  &lt;% if flag.present? %&gt;
    (&lt;code class="cmd-flag"&gt;&lt;%= flag %&gt;&lt;/code&gt;)
  &lt;% end %&gt;
  &lt;% unless opt %&gt;
    &lt;span class="required"&gt;*&lt;/span&gt;
  &lt;% end %&gt;
&lt;/label&gt;
</code></pre>
    <small>Main content of <em>_input_label.html.erb</em></small>
  </section>

<!-- ****************************** -->

  <section id="js_redone">
    <h3>About The Javascript</h3>
    The JavaScript code is templated: within the
    JS code loaded in the task's form, custom JS code
    is created by Ruby code.
    <p>
    Most of the time, these JS code snippets
    are small arrays or hashes of things related to the inputs.
    <p>
    The new integrator works like the old integrator
    in that regard, but the way the substitions are made
    has been greatly improved for clarity.
    <p>
    The next two slides show the before (old integrator) and
    after (new integrator).
  </section>

<!-- ****************************** -->

  <section id="js_redone_old">
    <h3>JS templating in <em>OLD</em> Integrator</h3>
    <img src="images/js_old.png">
    <small>Excerpts from <em>task_params.html.erb.erb</em></small>
  </section>

<!-- ****************************** -->

  <section id="js_redone_new">
    <h3>JS templating in <em>NEW</em> Integrator</h3>
    <img src="images/js_new.png">
    <small>Excerpts from <em>_form_js.html.erb</em></small>
  </section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section>

  <section id="part9">
    <h2>Part 9</h2>
    <h3>New Boutiques Integration</h3>
    <h5>Code Conventions</h5>
  </section>

<!-- ****************************** -->

  <section id="new_naming">
    <h3>Naming Things</h3>
    <ul>
      <li>The word 'Boutiques' was almost never used in the old integrator code</li>
      <li>The new integrator use it all the time:<br>
        <ul>
          <li>Classes: <em>BoutiquesTask::ToolName</em></li>
          <li>Classes: <em>BoutiquesSupport</em>, <em>BoutiquesSupport::BoutiquesDescriptor</em>, <em>BoutiquesSupport::BoutiquesInput</em> etc</li>
          <li>Paths: <em>cbrain_plugins/some-plugin/boutiques_descriptors</em></li>
          <li>Paths: <em>cbrain_plugins/installed-plugins/boutiques_descriptors</em></li>
        </ul>
      </li>
    </ul>
    So if something has 'boutiques' in it, it's part of the new integrator.
  </section>

<!-- ****************************** -->

  <section id="btq_support_methods">
    <h3>BoutiquesSupport Descriptor Methods</h3>
    The class has many helpful methods:
    <pre><code class="ruby" data-trim>
a = descriptor.inputs
b = descriptor.file_inputs
c = descriptor.required_file_inputs
d = descriptor.list_inputs
    </code></pre>
    These are much more elegant than<br>
    what used to be done in the old integrator:
    <pre><code class="ruby" data-trim>
b = params.select { |i| i['type'] == 'File' }
c = params.select { |i| i['type'] == 'File' &amp;&amp; ! i['optional'] }
d = params.select { |i| i['list'] }
    </code></pre>
    When working on this framework, add new methods as needed!
  </section>

<!-- ****************************** -->

  <section id="boutiques_task_class">
    <h3>The 'BoutiquesTask' Class</h3>
    There is a class called just <em>BoutiquesTask</em>.
    <p>
    It is used as a namespace for holding the real classes<br>
    for the tools (e.g. <em>BoutiquesTask::ToolName</em>).
    <p>
    It is not, however, ever instantiated.<br>
    It doesn't inherit from anything either:
    <pre><code class="ruby" data-trim>
class BoutiquesTask # not a AR model and does not inherit from no nothin'

  Revision_info=CbrainFileRevision[__FILE__] #:nodoc:

end
    </code></pre>
    <small>All of <em>cbrain-plugins-base/cbrain_task/boutiques_task/portal/boutiques_task.rb</em></small>
    <p>
    <i>Importantly</i>, the <em>views</em> subdirectory for that class is where all the
    partials for the new boutiques integrator are located.
  </section>

<!-- ****************************** -->

  <section id="invoke_params">
    <h3>New Convention For Task Params</h3>
    <div class="cell w50">
    <small>CbrainTask::MultiBoutiquesDemo</small>
    <pre><code class="json" data-trim>
{
  "interface_userfile_ids": [
    "14465",
    "14469"
  ],
  "sinput1": "14465",
  "minput1": "14469",
  "my_output_name": "outreport",
  "option_a": false,
  "option_h": false,
  "option_upper_h": true,
  "_cbrain_output_du_report_out": [
    14510
  ]
}
    </code></pre></div>
    <div class="cell">&nbsp;</div>
    <div class="cell w50">
    <small>BoutiquesTask::NewMultiBoutiquesDemo</small>
     <pre><code class="json" data-trim>
{
  "interface_userfile_ids": [
    "14465",
    "14469"
  ],
  "invoke": {
    "my_output_name": "outreport",
    "sinput1": "14465",
    "minput1": "14469",
    "option_a": false,
    "option_h": false,
    "option_upper_h": true
  },
  "_cbrain_output_du_report_out": [
    14510
  ]
}
    </code></pre></div>
    The goal is that the <em>"invoke"</em> subobject must
    work almost as-is as an input to the <strong>bosh</strong> utility,
    once serialized as a JSON file ('almost', because file names are
    replaced by Userfile IDs).
  </section>

<!-- ****************************** -->

  <section id="invoke_params2">
    <h3>New Task Access Method For Params</h3>
    Instead of accessing params using the long form:
    <pre><code class="ruby" data-trim>
# Old traditional way
opt_a = task.params[:invoke][:option_a]
task.params[:invoke][:option_upper_h] = true
    </code></pre>
    All BoutiquesTask objects have the helper <em>invoke_params()</em>:
    <pre><code class="ruby" data-trim>
# Through the helper 'invoke_params'
opt_a = task.invoke_params[:option_a]
task.invoke_params[:option_upper_h] = true
    </code></pre>
    Within a task object, then we can even get rid of the receiver:
    <pre><code class="ruby" data-trim>
def some_task_method
  opt_a = invoke_params[:option_a]
end
    </code></pre>
  </section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section>

  <section id="part10">
    <h2>Part 10</h2>
    <h3>New Boutiques Integration</h3>
    <h5>Customization And Configuration</h5>
  </section>

<!-- ****************************** -->

  <section id="inherit1">
    <h3>Override: Task Class 1</h3>
    As explained in <a href="#/new_boot_btq_class">Part 6</a>, by default a descriptor creates<br>
    a task class named <em>BoutiquesTask::ToolName</em>
    <pre><code class="ruby" data-trim>
class BoutiquesTask::ToolName &lt; BoutiquesPortalTask
end
    </code></pre>
    <small>Internally generated code at boot time (on Portal side)</small>
    <p>
    This class inherits all the basic functionality for providing<br>
    a behavior based on a descriptor (here, from <em>BoutiquesPortalTask</em>)
  </section>

<!-- ****************************** -->

  <section id="inherit2">
    <h3>Override: Task Class 2</h3>
    However, the descriptor can contain an override to<br>
    specify an alternate superclass to inherit from:
    <pre class="transp"><code class="json" data-trim>
{
    "name": "supertool",
    "tool-version": "1.0",
(...)
    "custom": {
      "cbrain:inherits-from-class": "MySuperHandler"
    }
}
    </code></pre>
    The boot-time code will then instead create the handler class as:
    <pre><code class="ruby" data-trim>
class BoutiquesTask::ToolName &lt; MySuperHandler
end
    </code></pre>
    <small>Internally generated code at boot time (on Portal side)</small><br>
    Presumably, <em>MySuperHandler</em> inherits from <em>BoutiquesPortalTask</em>
    but overrides some of its behavior. The code for <em>MySuperHandler</em>
    can be packaged within "lib/" in a plugin's structure.
  </section>

<!-- ****************************** -->

  <section id="desc_methods1">
    <h3>Override: Descriptor Methods 1</h3>
    The base classes for the new integrator all define<br>
    methods that return the same descriptor:
    <pre><code class="ruby" data-trim>
def boutiques_descriptor
  self.tool_config.boutiques_descriptor
end

def descriptor_for_before_form
  self.boutiques_descriptor
end

def descriptor_for_after_form
  self.boutiques_descriptor
end

def descriptor_for_final_task_list
  self.boutiques_descriptor
end
#etc...
    </code></pre>
    <small>Excerpts from <em>boutiques_portal_task.rb</em></small><br>
    These are the methods invoked by (respectively)<br>
    <em>before_form()</em>, <em>after_form()</em> etc.
  </section>

<!-- ****************************** -->

  <section id="desc_methods2">
    <h3>Override: Descriptor Methods 2</h3>
    So, given that the superclass has been overriden<br>
    as described in the previous slides, the new superclass<br>
    can 'temper' with the descriptor and change the behavior<br>
    of the integrator:
    <pre><code class="ruby" data-trim>
class MySuperHandler &lt; BoutiquesPortalTask

  # Integration with this class removes one input parameter,
  # but just during "before_form".
  def descriptor_for_before_form
    modified_desc = super.dup
    modified_desc.inputs.reject! { |input| input.id == 'numcpus' }
    modified_desc
  end

end
    </code></pre>
  </section>

<!-- ****************************** -->

  <section id="override_partials1">
    <h3>Override: Partials</h3>
    The set of view partials described in <a href="#/partials">Part 8</a> are stored<br>
    in the <em>cbrain-plugins-base</em> plugin, in the "views/" directory<br>
    for the task named <em>boutiques_task</em> (which is not itself ever instantiated).
    <p>
    Again, if the superclass has been overriden and it is coded as<br>
    a standard task class (e.g. <em>CbrainTask::SuperHandler</em>) within a plugin,<br>
    then any partial can be replaced as needed:
    <pre class="ascode">
boutiques_descriptors/my_tool.json  <strong># with cbrain:inherits set to CbrainTask::SuperHandler</strong>
cbrain_task/super_handler/portal/super_handler.rb
cbrain_task/super_handler/bourreau/super_handler.rb
cbrain_task/super_handler/view/_input_label.html.erb <strong># custom labels!</strong>
</pre>
    <small>List of files in an example plugin, with annotations</small><p>
    You only need to redefine the partials that you want, the others
    will be fetched from the base location.
  </section>

<!-- ****************************** -->

  <section id="override_desc_in_tc">
    <h3>Override: Descriptor For ToolConfigs</h3>
    As described in <a href="#/new_boot_load">Part 6</a>, descriptors
    for the new integrator are all loaded and associated with ToolConfig
    objects, at boot time.
    <p>
    Most of the time, this is enough. However, an admin, using the<br>
    interface, can provide or override a ToolConfig's descriptor by<br>
    providing a path to a JSON file.
    <p>
    <img src="images/tool_config.png">
    The attribute can have four 'states':<br>
    <b>Automatic</b>, <b>Manual</b>, <b>Overriden</b> or <b>None</b>.
  </section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

<section>

  <section id="end">
    <h2>The End</h2>
    <h3 class="glow">Thank you</h3>

    <strong>The base Ruby Integration framework was created by:</strong>
    <br>
    Pierre Rioux
    <p>
    <strong>The original Boutiques Integrator  was created by:</strong>
    <br>
    R&eacute;mi Bernard, Tristan Aumentado-Armstrong<br>
    Tristan Glatard, Pierre Rioux
    <p>
    <strong>The new Boutiques Integrator was created by:</strong>
    <br>
    Pierre Rioux
    <p>
    <strong>Project management:</strong>
    <br>
    Marc-&Eacute;tienne Rousseau,
    Shawn Brown,
    Bryan Caron
  </section>

</section>

<!-- ############################## -->
<!-- ############################## -->
<!-- ############################## -->

    </div>
  </div>

  <!-- Declares a filter to turn white into CBRAIN blue, #05A3D6 -->

  <svg height="0">
    <filter id="cbrainblue">
      <feColorMatrix values="0.0196 0.0    0.0    0 0
                             0.0    0.6392 0.0    0 0
                             0.0    0.0    0.8392 0 0
                             0      0      0      1 0"/>
    </filter>
  </svg>

  <!-- Main reveal.js setup -->

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    Reveal.initialize(
      {
        slideNumber:       true,
        history:           true
      }
    );
    hljs.initHighlightingOnLoad();
  </script>

  <!-- Styles -->

  <style>

    /* Headers */

    @keyframes glowing {
        0% { text-shadow: 0.0em 0.0em 0.0em #0cc; }
       25% { text-shadow: 0.0em 0.0em 0.2em #0dd; }
       50% { text-shadow: 0.0em 0.0em 0.4em #0ee; }
       75% { text-shadow: 0.0em 0.0em 0.2em #0dd; }
      100% { text-shadow: 0.0em 0.0em 0.0em #0cc; }
    }

    .reveal h1,
    .reveal h2,
    .reveal h3,
    .reveal h4,
    .reveal h5 {
      color: #ffffff;
      text-shadow: 0.0em 0.0em 0.2em #0cc;
    }

    /* Text styles: em, strong, b, i */

    .reveal .glow {
      animation: glowing 3555ms infinite;
    }

    .reveal em {
      color: yellow;
      font-style: normal; /* yes please! */
    }
    .reveal strong {
      color: #0ff;  /* funny, I'm using RGB with only three digits today */
    }
    .reveal b {
      color: #00f;
    }
    .reveal i {
      color: #f00;
      font-style: normal; /* yes please! */
    }

    /* Misc */

    .reveal section img {
      background: transparent;
      border: none;
      box-shadow: none;
    }
    .reveal section img.cbblue {
      filter: url(#cbrainblue);
    }
    .reveal pre {
      background: #033;
      /* padding: 0.2em 0.5em 0.3em 0.5em; */
      padding: 0;
      width: auto;
    }
    .reveal pre.ascode {
      background: #23241f;
      padding: 0.2em 0.5em 0.3em 0.5em;
    }
    .reveal pre.compact {
      display: inline-block;
    }
    .reveal pre.large {
      font-size: 120%;
    }
    .reveal pre.medium {
      font-size: 100%;
    }
    .reveal pre.supersmall {
      font-size: 40%;
    }
    .reveal pre > code.nomaxheight {
      max-height: none;
    }
    .reveal .cell {
      display: table-cell;
    }
    .reveal .w50 {
      width: 50%;
    }
    .reveal th {
      color: #0aa;
    }
    .reveal .transp {
      background-color: transparent;
    }
    .reveal .resize80 { /* for pics */
      width: 80%;
      height: 80%;
    }
    .reveal .resize40 { /* for pics */
      width: 40%;
      height: 40%;
    }
    .reveal .resize10 { /* for pics */
      width: 10%;
      height: 10%;
    }

    .hljs-comment {  /* I don't like the default grey */
      color: #c9a929;
    }

  </style>
</body>

</html>
